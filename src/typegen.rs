use anyhow::{Context, Result};
use serde_json::{Map, Value};
use std::path::Path;

/// Generate TypeScript type definitions from translation JSON files
pub fn generate_types(
    locales_dir: &Path,
    output_path: &Path,
    default_locale: &str,
) -> Result<()> {
    let mut resources: Map<String, Value> = Map::new();

    // Read the default locale's translation files
    let locale_dir = locales_dir.join(default_locale);
    if !locale_dir.exists() {
        return Ok(()); // No locale files yet
    }

    // Read all JSON files in the locale directory
    for entry in std::fs::read_dir(&locale_dir)
        .with_context(|| format!("Failed to read locale directory: {}", locale_dir.display()))?
    {
        let entry = entry?;
        let path = entry.path();

        if path.extension().map(|e| e == "json").unwrap_or(false) {
            let namespace = path
                .file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or("translation");

            let content = std::fs::read_to_string(&path)
                .with_context(|| format!("Failed to read: {}", path.display()))?;

            let json: Value = serde_json::from_str(&content)
                .with_context(|| format!("Failed to parse: {}", path.display()))?;

            resources.insert(namespace.to_string(), json);
        }
    }

    if resources.is_empty() {
        return Ok(());
    }

    // Generate TypeScript content
    let ts_content = generate_ts_content(&resources);

    // Ensure output directory exists
    if let Some(parent) = output_path.parent() {
        std::fs::create_dir_all(parent)?;
    }

    // Write the TypeScript file
    std::fs::write(output_path, ts_content)
        .with_context(|| format!("Failed to write: {}", output_path.display()))?;

    Ok(())
}

/// Generate TypeScript interface content from resources
fn generate_ts_content(resources: &Map<String, Value>) -> String {
    let mut output = String::new();

    // Header comment
    output.push_str("// This file is auto-generated by i18next-turbo\n");
    output.push_str("// Do not edit manually\n\n");

    // Generate interface for each namespace
    for (namespace, value) in resources {
        let interface_name = to_pascal_case(namespace);
        output.push_str(&format!("interface {} {{\n", interface_name));
        generate_interface_body(&mut output, value, 1);
        output.push_str("}\n\n");
    }

    // Generate the Resources interface
    output.push_str("interface Resources {\n");
    for namespace in resources.keys() {
        let interface_name = to_pascal_case(namespace);
        output.push_str(&format!("  \"{}\": {};\n", namespace, interface_name));
    }
    output.push_str("}\n\n");

    // Export declaration
    output.push_str("export { Resources };\n");
    output.push_str("export default Resources;\n");

    output
}

/// Generate interface body recursively
fn generate_interface_body(output: &mut String, value: &Value, depth: usize) {
    let indent = "  ".repeat(depth);

    if let Value::Object(obj) = value {
        for (key, val) in obj {
            let key_safe = if key.contains('.') || key.contains('-') {
                format!("\"{}\"", key)
            } else {
                key.clone()
            };

            match val {
                Value::Object(_) => {
                    output.push_str(&format!("{}{}: {{\n", indent, key_safe));
                    generate_interface_body(output, val, depth + 1);
                    output.push_str(&format!("{}}};\n", indent));
                }
                Value::String(_) => {
                    output.push_str(&format!("{}{}: string;\n", indent, key_safe));
                }
                _ => {
                    output.push_str(&format!("{}{}: unknown;\n", indent, key_safe));
                }
            }
        }
    }
}

/// Convert namespace to PascalCase for interface name
fn to_pascal_case(s: &str) -> String {
    s.split(|c: char| c == '-' || c == '_' || c == '.')
        .filter(|part| !part.is_empty())
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("translation"), "Translation");
        assert_eq!(to_pascal_case("common-errors"), "CommonErrors");
        assert_eq!(to_pascal_case("my_namespace"), "MyNamespace");
    }

    #[test]
    fn test_generate_ts_content() {
        let mut resources = Map::new();

        let mut translation = Map::new();
        translation.insert("hello".to_string(), Value::String("Hello".to_string()));

        let mut button = Map::new();
        button.insert("submit".to_string(), Value::String("Submit".to_string()));
        button.insert("cancel".to_string(), Value::String("Cancel".to_string()));
        translation.insert("button".to_string(), Value::Object(button));

        resources.insert("translation".to_string(), Value::Object(translation));

        let ts = generate_ts_content(&resources);

        assert!(ts.contains("interface Translation {"));
        assert!(ts.contains("hello: string;"));
        assert!(ts.contains("button: {"));
        assert!(ts.contains("submit: string;"));
        assert!(ts.contains("interface Resources {"));
        assert!(ts.contains("\"translation\": Translation;"));
    }
}
