use anyhow::{Context, Result};
use serde_json::{Map, Value};
use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;

/// Generate TypeScript type definitions from translation JSON files
pub fn generate_types(locales_dir: &Path, output_path: &Path, default_locale: &str) -> Result<()> {
    let mut resources: Map<String, Value> = Map::new();

    // Read the default locale's translation files
    let locale_dir = locales_dir.join(default_locale);
    if !locale_dir.exists() {
        return Ok(()); // No locale files yet
    }

    // Read all JSON files in the locale directory
    for entry in std::fs::read_dir(&locale_dir)
        .with_context(|| format!("Failed to read locale directory: {}", locale_dir.display()))?
    {
        let entry = entry?;
        let path = entry.path();

        if path.extension().map(|e| e == "json").unwrap_or(false) {
            let namespace = path
                .file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or("translation");

            let content = std::fs::read_to_string(&path)
                .with_context(|| format!("Failed to read: {}", path.display()))?;

            let json: Value = serde_json::from_str(&content)
                .with_context(|| format!("Failed to parse: {}", path.display()))?;

            resources.insert(namespace.to_string(), json);
        }
    }

    if resources.is_empty() {
        return Ok(());
    }

    // Ensure output directory exists
    if let Some(parent) = output_path.parent() {
        std::fs::create_dir_all(parent)?;
    }

    // Write to temp file first, then atomically rename
    let temp_path = output_path.with_extension("d.ts.tmp");
    {
        let file = File::create(&temp_path)
            .with_context(|| format!("Failed to create temp file: {}", temp_path.display()))?;
        let mut writer = BufWriter::new(file);

        // Stream TypeScript content directly to file
        write_ts_content(&mut writer, &resources)?;

        writer.flush()?;
    }

    // Atomic rename
    std::fs::rename(&temp_path, output_path)
        .with_context(|| format!("Failed to rename temp file to: {}", output_path.display()))?;

    Ok(())
}

/// Stream TypeScript content directly to a writer (memory-efficient)
fn write_ts_content<W: Write>(writer: &mut W, resources: &Map<String, Value>) -> Result<()> {
    // Header comment
    writeln!(writer, "// This file is auto-generated by i18next-turbo")?;
    writeln!(writer, "// Do not edit manually\n")?;

    // Generate interface for each namespace
    for (namespace, value) in resources {
        let interface_name = to_pascal_case(namespace);
        writeln!(writer, "interface {} {{", interface_name)?;
        write_interface_body(writer, value, 1)?;
        writeln!(writer, "}}\n")?;
    }

    // Generate the Resources interface
    writeln!(writer, "interface Resources {{")?;
    for namespace in resources.keys() {
        let interface_name = to_pascal_case(namespace);
        writeln!(writer, "  \"{}\": {};", namespace, interface_name)?;
    }
    writeln!(writer, "}}\n")?;

    // Export declaration
    writeln!(writer, "export {{ Resources }};")?;
    writeln!(writer, "export default Resources;")?;

    Ok(())
}

/// Stream interface body recursively to a writer
fn write_interface_body<W: Write>(writer: &mut W, value: &Value, depth: usize) -> Result<()> {
    let indent = "  ".repeat(depth);

    if let Value::Object(obj) = value {
        for (key, val) in obj {
            let key_safe = if key.contains('.') || key.contains('-') {
                format!("\"{}\"", key)
            } else {
                key.clone()
            };

            match val {
                Value::Object(_) => {
                    writeln!(writer, "{}{}: {{", indent, key_safe)?;
                    write_interface_body(writer, val, depth + 1)?;
                    writeln!(writer, "{}}};", indent)?;
                }
                Value::String(_) => {
                    writeln!(writer, "{}{}: string;", indent, key_safe)?;
                }
                _ => {
                    writeln!(writer, "{}{}: unknown;", indent, key_safe)?;
                }
            }
        }
    }

    Ok(())
}

/// Generate TypeScript interface content from resources (for testing)
#[cfg(test)]
fn generate_ts_content(resources: &Map<String, Value>) -> String {
    let mut output = Vec::new();
    write_ts_content(&mut output, resources).expect("Failed to write to buffer");
    String::from_utf8(output).expect("Invalid UTF-8")
}

/// Convert namespace to PascalCase for interface name
fn to_pascal_case(s: &str) -> String {
    s.split(['-', '_', '.'])
        .filter(|part| !part.is_empty())
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("translation"), "Translation");
        assert_eq!(to_pascal_case("common-errors"), "CommonErrors");
        assert_eq!(to_pascal_case("my_namespace"), "MyNamespace");
    }

    #[test]
    fn test_generate_ts_content() {
        let mut resources = Map::new();

        let mut translation = Map::new();
        translation.insert("hello".to_string(), Value::String("Hello".to_string()));

        let mut button = Map::new();
        button.insert("submit".to_string(), Value::String("Submit".to_string()));
        button.insert("cancel".to_string(), Value::String("Cancel".to_string()));
        translation.insert("button".to_string(), Value::Object(button));

        resources.insert("translation".to_string(), Value::Object(translation));

        let ts = generate_ts_content(&resources);

        assert!(ts.contains("interface Translation {"));
        assert!(ts.contains("hello: string;"));
        assert!(ts.contains("button: {"));
        assert!(ts.contains("submit: string;"));
        assert!(ts.contains("interface Resources {"));
        assert!(ts.contains("\"translation\": Translation;"));
    }
}
